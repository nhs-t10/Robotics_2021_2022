{
  parserClass="net.coleh.autoautolanguageplugin.parse.AutoautoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Autoauto"
  psiImplClassSuffix="Impl"
  psiPackage="net.coleh.autoautolanguageplugin.parse"
  psiImplPackage="net.coleh.autoautolanguageplugin.parse.impl"

  elementTypeHolderClass="net.coleh.autoautolanguageplugin.parse.AutoautoTypes"
  elementTypeClass="net.coleh.autoautolanguageplugin.parse.AutoautoElementType"
  tokenTypeClass="net.coleh.autoautolanguageplugin.parse.AutoautoTokenType"

  psiImplUtilClass="net.coleh.autoautolanguageplugin.parse.AutoautoPsiUtilImpl"
}

autoautoFile ::=  commentOpportunity* [frontMatter] commentOpportunity* labeledStatepath* commentOpportunity*

frontMatter ::= DOLLAR_SIGN commentOpportunity* (frontMatterKeyValue COMMA)* frontMatterKeyValue commentOpportunity* DOLLAR_SIGN

frontMatterKeyValue ::= IDENTIFIER COLON commentOpportunity* value commentOpportunity*

commentOpportunity ::= comment [WHITESPACE_RANGE]

labeledStatepath ::= commentOpportunity* STATEPATH_LABEL_ID COLON commentOpportunity* statepath commentOpportunity* {methods=[getLabel]}

statepath ::=  commentOpportunity* (state SEMICOLON)* state [SEMICOLON] commentOpportunity*

state ::=  commentOpportunity* (statement COMMA)* statement [COMMA] commentOpportunity*

statement ::= singleStatement | multiStatement

multiStatement ::= commentOpportunity*  OPEN_CURLY_BRACKET statepath CLOSE_CURLY_BRACKET commentOpportunity*

singleStatement ::= commentOpportunity*  (afterStatement|funcDefStatement|functionCallStatement|gotoStatement|ifStatement|letStatement|nextStatement|skipStatement)  commentOpportunity*

afterStatement ::= AFTER unitValue statement

functionCallStatement ::= value

gotoStatement ::= GOTO (IDENTIFIER|dynamicValue)

ifStatement ::= (IF|WHEN) valueInParens statement

funcDefStatement ::= (FUNC|FUNCTION) (IDENTIFIER|dynamicValue) OPEN_PAREN [argumentList] CLOSE_PAREN statement

letStatement ::= LET (IDENTIFIER|dynamicValue) commentOpportunity* EQUALS commentOpportunity* value

nextStatement ::= NEXT

skipStatement ::= SKIP NUMERIC_VALUE

value ::= commentOpportunity*  (boolean) commentOpportunity* [tail]

tail ::= DOT value

valueInParens ::= commentOpportunity* OPEN_PAREN value CLOSE_PAREN commentOpportunity*

modulo ::= baseExpression [MODULUS baseExpression]
exponent ::= modulo [EXPONENTIATE modulo]
product ::= exponent [((MULTIPLY | DIVIDE) exponent)+]
sum ::= product [((PLUS | MINUS) product)+]
arithmeticValue ::= sum

baseExpression ::= commentOpportunity*  (arrayLiteral | functionCall | NUMERIC_VALUE | stringLiteral | unitValue | variableReference | valueInParens | booleanLiteral) commentOpportunity*

variableReference ::= IDENTIFIER

arrayLiteral ::= OPEN_SQUARE_BRACKET [argumentList] CLOSE_SQUARE_BRACKET

booleanLiteral ::= TRUE | FALSE

boolean ::= (arithmeticValue comparisonOperator arithmeticValue) | arithmeticValue

comparisonOperator ::= COMPARE_LT | COMPARE_LTE | COMPARE_EQ | COMPARE_NEQ | COMPARE_GTE | COMPARE_GT

functionCall ::= (IDENTIFIER|valueInParens|dynamicValue) commentOpportunity* OPEN_PAREN [argumentList] CLOSE_PAREN

stringLiteral ::= QUOTE NON_QUOTE_CHARACTER* QUOTE

unitValue ::= NUMERIC_VALUE_WITH_UNIT

comment ::= blockComment | lineComment

blockComment ::= COMMENT_BEGIN COMMENT_TEXT* COMMENT_END

lineComment ::= LINE_COMMENT_BEGIN COMMENT_TEXT* LINE_COMMENT_END

argumentList ::= (argument COMMA)* argument

argument ::= [value EQUALS] value

dynamicValue ::= OPEN_SQUARE_BRACKET value CLOSE_SQUARE_BRACKET
